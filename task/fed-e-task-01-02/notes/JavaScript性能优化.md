# JavaScript 性能优化

## 一、内存管理
内存：由可读写单元组成，表示一片可操作空间  
管理：人为的去操作一片空间的申请、使用和释放  
内存管理：开发者主动申请空间、使用空间、释放空间  
管理流程：申请——使用——释放

## 二、垃圾回收与常见 GC 算法
JavaScript 中的垃圾  
* JavaScript 中内存管理是自动的
* 对象不再被引用时是垃圾
* 对象不能从根上访问到时是垃圾

JavaScript 中的可达对象  
* 可以访问到的对象就是可达对象（引用、作用域链）  
* 可达的标准就是从根出发是否能够被找到  
* JavaScript 中的根就可以理解为是全局变量对象

JavaScript 中的引用和可达  

GC 算法介绍  
* GC 就是垃圾回收机制的简写  
* GC 可以找到内存中的垃圾、并释放和回收空间

GC 里的垃圾是什么  
* 程序中不再需要使用的对象  
* 程序中不能再访问到的对象

GC 算法是什么  
* GC 是一种机制，垃圾回收器完成具体的工作  
* 工作的内容就是查找垃圾释放空间、回收空间  
* 算法就是工作时查找和回收所遵循的规则

常见 GC 算法  
* 引用计数  
* 标记清除  
* 标记整理  
* 分代回收

引用计数算法实现原理  
* 核心思想：设置引用数，判断当前引用数是否为0  
* 引用计数器  
* 引用关系改变时修改引用数字  
* 引用数字为0时立即回收

引用计数算法优点  
* 发现垃圾时立即回收（可以即时回收垃圾对象）  
* 最大限度减少程序暂停（减少程序卡顿时间）

引用计数算法缺点  
* 无法回收循环引用的对象  
* 时间开销大（资源消耗较大）  

标记清除算法实现原理  
* 核心思想：分标记和清除两个阶段完成  
* 遍历所有对象找标记活动对象  
* 遍历所有对象清除没有标记对象  
* 回收相应的空间  

标记清除算法优缺点  
* 相对于引用计数来说，可以解决循环引用不能回收的问题  
* 会产生空间的碎片化的问题（地址的不连续），不能让我们的空间最大化的使用（浪费空间）  
* 不会立即回收垃圾对象

标记整理算法实现原理  
* 标记整理可以看作是标记清除的增强  
* 标记阶段的操作和标记清除一致  
* 清除阶段会先执行整理，移动对象位置

标记整理优缺点  
* 减少碎片化空间  
* 不会立即回收垃圾对象

常见 GC 算法总结  
* 引用计数  
* 标记清除  
* 标记整理

## 三、V8 引擎的垃圾回收
认识 V8
* V8 是一款主流的 JavaScript 执行引擎  
* V8 采用即时编译  
* V8 内存设限（64位/1.5G、32位/800M）

V8 垃圾回收策略  
* 采用分代回收的思想  
* 内存分为新生代、老生代  
* 针对不同对象采用不同算法

V8 中常用 GC 算法  
* 分代回收  
* 空间复制  
* 标记清除  
* 标记整理  
* 标记增量

V8 如何回收新生代对象  
* V8 内存空间一分为二  
* 小空间用于存储新生代对象（32M｜16M）  
* 新生代指的是存活时间较短的对象  

新生代对象回收实现  
* 回收过程采用复制算法 + 标记整理  
* 新生代内存区分为两个等大小空间  
* 使用空间为 From，空闲空间为 To  
* 活动对象存储于 From 空间  
* 标记整理后将活动对象拷贝至 To  
* From 与 To 交换空间完成释放

回收细节说明  
* 拷贝过程中可能出现晋升  
* 晋升就是将新生代对象移动至老生代  
* 一轮 GC 还存活的新生代需要晋升  
* To 空间的使用率超过 25%

V8 如何回收老年代对象  
* 老年代对象存放在右侧老生代区域  
* 64位操作系统1.4G，32操作系统700M  
* 老年代对象就是指存活时间较长的对象

老年代对象回收实现  
* 主要采用标记清除、标记整理、增量标记算法  
* 首先使用标记清除完成垃圾空间的回收  
* 采用标记整理进行空间优化  
* 采用增量标记进行效率优化

细节对比  
* 新生代区域垃圾回收使用空间换时间  
* 老生代区域垃圾回收不适合复制算法

标记增量如何优化垃圾回收

V8 垃圾回收总结  
* V8 是一款主流的 JavaScript 执行引擎  
* V8 内存设置上限  
* V8 采用基于分代回收思想实现垃圾回收  
* V8 内存分为新生代、老生代  
* V8 垃圾回收常见的 GC 算法

## 四、Performance 工具
为什么使用 Performance  
* GC 的目的是为了实现内存空间的良性循环  
* 良性循环的基石是合理使用  
* 时刻关注才能确定是否合理  
* Performance 提供多种监控方式

通过 Performance 时刻监控内存

Performance 使用步骤  
* 打开浏览器输入目标网址  
* 进入开发人员工具面板，选择性能  
* 开启录制功能，访问具体界面  
* 执行用户行为，一段时间后停止录制  
* 分析界面中记录的内存信息

内存问题的体现  
* 页面出现延迟加载或经常性暂停  
* 页面持续性出现糟糕的性能  
* 页面的性能随时间延长越来越差

界定内存问题的标准  
* 内存泄漏：内存使用持续升高  
* 内存膨胀：在多数设备上都存在性能问题  
* 频繁垃圾回收：通过内存变化图进行分析

监控内存的几种方式  
* 浏览器任务管理器（shift + esc，监控内存，判断是否存在问题）  
* Timeline 时序图记录（检查 + 性能，记录内存，定位问题）  
* 堆快照查找分离 DOM（检查 + 内存，deta，定位问题）  
* 判断是否存在频繁的垃圾回收

什么是分离 DOM  
* 界面元素存活在 DOM 树上  
* 垃圾对象时的 DOM 节点  
如果这个节点从当前DOM树上进行了脱离，而且在js代码中也没有引用  
* 分离状态的 DOM 节点  
当前的DOM节点只是从当前DOM树上脱离了，但是在js代码中还有在引用。在界面上是看不见的，但是在内存里面是占据着空间的，所以在这种情况下就是一种内存泄露

为什么确定频繁垃圾回收  
* GC 工作是应用程序是停止的  
* 频繁且过长的 GC 会导致应用假死  
* 用户使用中感知应用卡顿

确定频繁的垃圾回收  
* Timeline 中频繁的上升下降  
* 任务管理器中数据频繁的增加减小

## 五、代码优化实例
如何精准测试 JavaScript 性能  
* 本质上就是采集大量的执行样式进行数学统计和分析  
* 使用基于 Benchmark.js 的 https://jsperf.com/ 完成

Jsperf 使用流程  
* 使用 Github 账号登录  
* 填写个人信息（非必须）  
* 填写详细的测试用例信息（title、slug）  
* 填写准备代码（DOM操作时经常使用）  
* 填写必要有 setup 与 teardown 代码  
* 填写测试代码片段

慎用全局变量  
* 全局变量定义在全局执行上下文，是所有作用域链的顶端  
* 全局执行上下文一直存在于上下文执行栈，直到程序退出  
* 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

缓存全局变量  
将使用中无法避免的全局变量缓存到局部

通过原型新增方法  
在原型对象上新增实例对象需要的方法  

避开闭包陷阱


