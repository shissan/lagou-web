# fed-e-task-01-02
大前端part1 JavaScript 深度剖析
模块一 ES 新特性与 TypeScript、JS 性能优化
作业

## 简单题
### 一、请说出下列最终的执行结果，并解释为什么
```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[6]()
```
执行结果为10

for循环中返回了闭包，闭包中保存了变量对象i，由于是使用的var，i其实是全局对象  
for循环一下子就执行完毕了，最后i的值是10  
闭包保存的是整个变量对象，而不是某个特殊的变量  
所以最近执行a[6]()时，输入的是最后一个值10  

如果把var改成let，形成块级作用域，执行结果即为6


### 二、请说出下列最终的执行结果，并解释为什么
```
var tmp = 123;

if (true) {
  console.log(tmp)
  let tmp
}
```
console.log(tmp) 会报错 ReferenceError: Cannot access 'tmp' before initialization

ES6规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。这在语法上，称为“暂时性死区”  
总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的，凡是在声明之前就使用这些变量，就会报错  
let和const 没有变量提升


### 三、结合 ES6 新语法，用最简单的方式找出数组中的最小值
```
var arr = [12, 34, 32, 89, 4];

const min = Math.min(...arr);
console.log(min)   // 4
```

### 四、请详细说明 var，let，const 三种声明变量的方式之间的具体差别
1. var声明的变量存在变量提升，let和const没有  
2. var和let声明的变量可以不初始化，const必须初始化且不可更改  
3. let和const声明的变量会形成块级作用域，而var声明的变量只有全局作用域和函数作用域


### 五、请说出下列代码最终输出的结果，并解释为什么
```
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```
输出20

setTimeout中的回调函数函数是箭头函数，箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象，也就是指fn  
fn()是对象obj的成员方法，在调用时fn内的this指向函数的调用者，也就是obj

### 六、简述 Symbol 类型的用途
最主要的作用就是为对象添加独一无二的属性名，不必担心同名属性覆盖的问题  
可以用Symbol创建私有成员的属性名，通过Object.keys()、for...in循环无法获取到Symbol类型的key  
```
console.log(Symbol() === Symbol())  // false
```

### 七、说说什么是浅拷贝，什么是深拷贝
JavaScript 的数据类型有哪些，一般分为`基本类型`和`引用类型`。基本类型是不可变的，引用类型可以添加、删除属性和方法。基本类型保存在`栈内存`中，而引用类型保存在`堆内存`中。保存在`栈内存`的必须是大小固定的数据，引用类型的大小不固定，只能保存在`堆内存`中，但是我们可以把它的地址写在`栈内存`中以供访问。

之所以会出现深浅拷贝，是由于 JS 对`基本类型`和`引用类型`的处理不同。基本类型指的是简单的数据段，而引用类型指的是一个对象保存在堆内存中的地址，JS 不允许我们直接操作内存中的地址，也就是说不能操作对象的内存空间，所以，我们对对象的操作都只是操作它的引用而已。  
在复制时也是一样，如果我们复制一个`基本类型`的值时，会创建一个新值，并把它保存在新的变量的位置上。而如果我们复制一个`引用类型`时，同样会把变量中的值复制一份放到新的变量空间里，但此时复制的东西并不是对象本身，而是指向该对象的`指针`。所以我们复制`引用类型`后，两个变量其实指向同一个对象，所以改变其中的一个对象，会影响到另外一个。

**浅拷贝**  
浅拷贝只是复制基本类型的数据或者指向某个对象的指针，而不是复制对象本身，源对象和目标对象共享同一块内存；若对目标对象进行修改，存在源对象被篡改的可能。

**深拷贝**  
深拷贝能够实现真正意义上的对象的拷贝，实现方法就是递归调用'浅拷贝'。深拷贝会创造一个一模一样的对象，其内容地址是自助分配的，拷贝结束之后，内存中的值是完全相同，但是内存地址是不一样的，目标对象跟源对象不共享内存，修改任何一方的值，不会对另外一方造成影响。

1. concat()、slice()  
若拷贝数组是纯数据（不含对象），可以通过concat()、slice()来实现深拷贝  
若拷贝数组中有对象，可以使用concat()、slice()来实现浅拷贝

2. Object.assign()、Object.create()  
Object.assign()、Object.create() 都是一层（根级）深拷贝，之下的级别为浅拷贝。

3. 对象的解构  
同上，一层（根级）深拷贝，之下的级别为浅拷贝

4. JSON.parse()  
用 JSON.stringify() 把对象转成字符串，再用 JSON.parse() 把字符串转成新的对象，可以实现对象的深复制


### 八、请简述 TypeScript 与 JavaScript 之间的关系
TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持  

引用官网的定义：
> TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source.

翻译成中文即是：
> TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。


### 九、请谈谈你所认为的 TypeScript 优缺点
优点：  
TypeScript 增加了代码的可读性和可维护性，非常包容  
类型系统实际上是最好的文档  
可以在编译阶段就发现大部分错误  
即使编译报错，也可以生成 JavaScript 文件

缺点：  
TypeScript 语言本身多了很多概念，要多写一些类型的定义，项目初期，有一定的学习成本和开发成本


### 十、描述引用计数的工作原理和优缺点
工作原理：通过引用计数器设置引用数，判断当前引用数是否为0，引用关系改变时修改引用数，引用数字为0时立即回收  
优点：可以即时回收垃圾对象，减少程序卡顿时间  
缺点：无法回收循环引用的对象，需要时刻监听计数器的变化，资源消耗较大


### 十一、描述标记整理算法的工作流程
分标记和清除两个阶段完成，第一阶段，遍历所有对象找活动对象进行标记，这个阶段和标记清除操作一致  
第二阶段，遍历所有对象，先执行整理，移动对象位置，使内存空间连续，清除没有标记的对象  
最后回收相应的空间


### 十二、描述 V8 中新生代存储区垃圾回收的流程
新生代对象回收过程采用复制算法 + 标记整理  
* 新生代内存区分为两个等大小空间（新生代的空间在64位系统与32位系统中的大小分别为32M和16M）  
* 使用空间为 From，空闲空间为 To  
* 活动对象存储于 From 空间  
* 当 From 空间使用到一定程度后，会触发GC  
* 标记整理后将 From 中的活动对象拷贝至 To  
* From 与 To 交换空间后，完成释放


### 十三、描述增量标记算法在何时使用及工作原理
主要在老生代对象进行垃圾回收时使用，采用增量标记进行效率优化  
工作原理：增量标记会将一整段的垃圾回收操作拆分为多个小部分进行标记，最后再进行清除。与程序的运行相互组合着完成整个垃圾回收，以替代之前先运行程序，再一口气进行垃圾回收的操作

